{"mappings":"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","sources":["src/helpers/utils.ts","node_modules/@parcel/node-resolver-core/lib/_empty.js","node_modules/path-browserify/index.js"],"sourcesContent":["import { ColorInfo } from 'schemas/matchData';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport { BundleImages } from 'schemas/bundleImages';\r\n\r\nexport const formatTimeHMSC = (ms: number): string => {\r\n\tms = ms > 0 ? ms : 0;\r\n\r\n\tconst hour = Math.floor(ms / 60 / 60 / 1000);\r\n\tms = ms % (60 * 60 * 1000);\r\n\r\n\tconst minute = Math.floor(ms / 60 / 1000);\r\n\tms = ms % (60 * 1000);\r\n\r\n\tconst second = Math.floor(ms / 1000);\r\n\tms = ms % 1000;\r\n\r\n\tconst centiseconds = Math.floor(ms / 10);\r\n\r\n\treturn `${hour}:${minute < 10 ? `0${minute}` : minute}:${second < 10 ? `0${second}` : second}.${centiseconds < 10 ? `0${centiseconds}` : centiseconds}`\r\n}\r\n\r\nexport const formatDateHM = (date: Date) => {\r\n\treturn date.getHours() + \":\" + ((date.getMinutes() < 10) ? \"0\" : \"\") + date.getMinutes();\r\n};\r\n\r\nexport const formatDateMDY = (date: Date) => {\r\n\treturn (date.getMonth() + 1) + \"/\" + date.getDate() + \"/\" + date.getFullYear();\r\n}\r\n\r\nexport const modulo = (dividend: number, divisor: number) => {\r\n\treturn ((dividend % divisor) + divisor) % divisor;\r\n}\r\n\r\nexport const getIndexColor = (index: number, list: ColorInfo[], swap: boolean) => {\r\n\treturn !swap ? list[modulo(index, list.length)].teamA : list[modulo(index, list.length)].teamB;\r\n}\r\n\r\nexport const lerp = (a: number, b: number, alpha: number) => { return a + alpha * (b - a)};\r\n\r\nexport const clamp = (value: number, min: number, max: number) => { return Math.min(Math.max(value, min), max)};\r\n\r\n/**\r\n * acceptedFiles can only be 1 file, it is an array to facilitate easy use of react-dropzone\r\n */\r\nexport const fileToJSON = (acceptedFiles: File[], onImport: (json: unknown) => void, onError: (error: string) => void) => {\r\n\tif(acceptedFiles.length > 1)\r\n\t{\r\n\t\tonError(\"Only one file can be imported at a time.\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tif(acceptedFiles.length == 0)\r\n\t{\r\n\t\tonError(\"An unknown issue occurred while trying to load the file. (No files were accepted?)\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst [ file ] = acceptedFiles;\r\n\r\n\tfile.text().then((value: string) => {\r\n\t\ttry {\r\n\t\t\tconst importedJSON = JSON.parse(value);\r\n\t\t\tonImport(importedJSON);\r\n\r\n\t\t} catch (error) {\r\n\t\t\tonError(`The file could not be read: ${error}.`);\r\n\t\t}\r\n\t}).catch((error) => {\r\n\t\tonError(`The file could not be read: ${error}`);\r\n\t});\r\n}\r\n\r\nexport const exportJSON = (json: unknown, fileName: string) => {\r\n\tconst a = document.createElement('a');\r\n\r\n\ta.href = URL.createObjectURL(new Blob([JSON.stringify(json)], { type: 'text/plain' }));\r\n\r\n\ta.setAttribute('download', fileName);\r\n\r\n\tdocument.body.appendChild(a);\r\n\r\n\ta.click();\r\n\r\n\tdocument.body.removeChild(a);\r\n}\r\n\r\nexport const getImagePath = (bundle: string, imagePath: string) => {\r\n\treturn `\\\\bundles\\\\${bundle}\\\\images\\\\${imagePath}`;\r\n}\r\n\r\n//\r\n// Server-side Only\r\n//\r\n\r\nconst imageExtensions = new Set([ 'png', 'jpg', 'jpeg', 'gif' ]);\r\n\r\nconst isFileExtensionImage = (name: string) => {\r\n\treturn imageExtensions.has(path.extname(name).slice(1).toLowerCase());\r\n}\r\n\r\nexport const getItems = (filePath: string, filter: (value: fs.Dirent) => boolean, recursive?: boolean) => {\r\n\tconst files = fs.readdirSync(filePath, { withFileTypes: true, recursive });\r\n\r\n\treturn files.filter(filter).map(value => {\r\n\t\treturn path.relative(filePath, path.join(value.parentPath || value.path, value.name));\r\n\t});\r\n}\r\n\r\nexport const getDirectories = (filePath: string, recursive?: boolean) => {\r\n\treturn getItems(filePath, (value) => value.isDirectory(), recursive);\r\n}\r\n\r\nexport const getFiles = (path: string, recursive?: boolean) => {\r\n\treturn getItems(path, (value) => value.isFile(), recursive);\r\n}\r\n\r\nexport const getImages = (filePath: string, recursive?: boolean) => {\r\n\treturn getItems(filePath, (value) => { \r\n\t\treturn value.isFile() && isFileExtensionImage(value.name); } , recursive);\r\n}\r\n\r\nexport const updateBundleImages = (bundleImages: BundleImages) => {\r\n\tbundleImages.bundles = getDirectories('bundles');\r\n\r\n\tif(!bundleImages.bundles.includes(bundleImages.selectedBundle)) {\r\n\t\tbundleImages.selectedBundle = bundleImages.bundles[0];\r\n\t}\r\n\r\n\tconst bundlePath = path.join('bundles', path.join(bundleImages.selectedBundle));\r\n\r\n\tconst imagePath = path.join(bundlePath, 'images');\r\n\r\n\tif(fs.existsSync(imagePath)) {\r\n\t\tbundleImages.images = getImages(imagePath, true);\r\n\t}\r\n\telse {\r\n\t\tbundleImages.images = [];\r\n\t}\r\n\r\n\treturn bundleImages;\r\n}","\"use strict\";","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n"],"names":["ColorInfo","fs","path","BundleImages","formatTimeHMSC","ms","hour","Math","floor","minute","second","centiseconds","formatDateHM","date","Date","getHours","getMinutes","formatDateMDY","getMonth","getDate","getFullYear","modulo","dividend","divisor","getIndexColor","index","list","swap","length","teamA","teamB","lerp","a","b","alpha","clamp","value","min","max","fileToJSON","acceptedFiles","File","onImport","json","onError","error","file","text","then","importedJSON","JSON","parse","catch","exportJSON","fileName","document","createElement","href","URL","createObjectURL","Blob","stringify","type","setAttribute","body","appendChild","click","removeChild","getImagePath","bundle","imagePath","imageExtensions","Set","isFileExtensionImage","name","has","extname","slice","toLowerCase","getItems","filePath","filter","Dirent","recursive","files","readdirSync","withFileTypes","map","relative","join","parentPath","getDirectories","isDirectory","getFiles","isFile","getImages","updateBundleImages","bundleImages","bundles","includes","selectedBundle","bundlePath","existsSync","images"],"version":3,"file":"time.8d3b378c.js.map","sourceRoot":"../"}